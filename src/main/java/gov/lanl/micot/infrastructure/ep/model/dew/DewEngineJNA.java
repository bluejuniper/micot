package gov.lanl.micot.infrastructure.ep.model.dew;

import java.io.File;
import java.util.Arrays;
import java.util.List;

import com.sun.jna.Library;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;

public interface DewEngineJNA extends Library {

	public final static String os = System.getProperty("os.arch").equals("x86") ? "32bit" : "64bit";  
	public final static String dll = "DEWEngine.dll";

  public final static String userDir = System.getProperty("user.dir");
  public final static String path = userDir.substring(0, userDir.lastIndexOf(File.separatorChar) + 1) + "micot-libraries"
      + File.separatorChar + "dewlib" + File.separatorChar + os
      + File.separatorChar;

  
	/**
	 * Instance of the native DEWEngine.dll library. The path to the lib directory
	 * of the project has been specified as a VM argument,
	 * -Djna.library.path=C:/Users/180380/Workspace/gov.lanl.dewwrap/lib/
	 * And just to cover all the bases, I've also added this directory to the
	 * PATH environment variable in my windows account.
	 */
	DewEngineJNA INSTANCE = DewLoader.loadDew(path+dll); //(DewEngineJNA) Native.loadLibrary(path+dll, DewEngineJNA.class);
		
	/**
	 * Definition of the TxtMsg structure that the DEWEngine.dll uses for passing
	 * messages back to the user.
	 */
	public static class TxtMsg extends Structure {
		public static class ByReference extends TxtMsg implements Structure.ByReference { }
		public int messageLevel;
		public int moduleID;
		public int messageID;
		public char CmpSN;
		public Pointer pMsgTxt; // actually is a char* in c header
		public TxtMsg.ByReference pNextMsg;
		@Override
		protected List getFieldOrder() {
			return Arrays.asList("messageLevel", "moduleID", "messageID", "CmpSN","pMsgTxt", "pNextMsg");
		}
	}
	
	/**
	 * Load the DEW engine.
	 * @return 1 if succeeded; 0 if failed
	 */
	public int LoadDewEngine();
	
	/** 
	 * This method is used to load the DEW Engine, establish communications
	 * with the DEW database and initialize the Engine.
	 * 
	 * @param dbConnStr ODBC Connection string for connection to the DEW database
	 * @return 1 if succeeded; 0 if failed
	 */
	public int StartDewEngine(String connString);
	
	/**
	 * This method is used to remove data from memory, release memory, disconnect
	 * from the DEW database, and unload the DEW Engine.
	 * @return 1 if succeeded; 0 if failed
	 */
	public int StopDewEngine();
	
    /**
     * Opens the system from a file name
     * @param sysFileName
     * @return 
     */
    public int OpenSystemFromFile (String sysFileName);

    /**
     * Get results generated by the analysis
     * @param appID
     * @param varID
     * @return 
     */
    public Pointer GetAllResultsByUID (int appID, int varID);
	
	/**
	 * Retrieve messages from the engine
	 * @return A TxtMsg structure containing the message info.
	 */
	public TxtMsg GetEWIMessages();
	
	/**
	 * This method is used to reset the EWI system to initial state and release any
	 * memory no longer needed.
	 */
	public void ResetEWI();
	
	/**
	 * Adds a component to the currently selected model.
	 * 
	 * @param cktId Unique identifier of circuit to associate component with
	 * @param iCmp Index into ApiCmpIdx table for type of component to add (not sure
	 * where this is).
	 * @param partIndex Index into appropriate part table for type of component
	 * being added.
	 * @param fdCmpId Unique identifier for feeder path component (that is, added
	 * component is attached to this component).
	 * @param name Name of component.
	 * @param cmpId ID of component.
	 * @param xEndPt x coordinate (ending coordinate for components with length)
	 * @param yEndPt y coordinate (ending coordinate for components with length)
	 * @param length Length of component (set to -1 to have length computed automatically).
	 * @param year Year of installation.
	 * @param rating kVA rating for transformers or total install kVAR for capacitors.
	 * @param phases Phasing present (A, B, C, AB, CA, BC, or ABC)
	 * @param partIndex2 see documentation
	 * @param partIndex3 see documentation
	 * @param switchState For sectionalizing devices = {open, close}
	 * @param controlDevStep Regulating transformers: tap step; regulating capacitors:
	 * step; switched capacitors: state as on (1) or off (0)
	 * @param xfrmTapConIndx Tap connection index (in ApiXfrmConIdx) for a multi-bank
	 * transformer.
	 * @param xfrmTapSetting Index in PtTapSetIdx for internal Tap setting for multi-tap
	 * transformers.
	 * @param text Component text (max length of 30 characters)
	 * @return Success (1) or failure (0)
	 */
	public int AddCmpEx(
			String cktId,
			int iCmp,
			long partIndex,
			String fdCmpId,
			String name,
			String cmpId,
			long xEndPt,
			long yEndPt,
			double length,
			long year,
			double rating,
			String phases,
			long partIndex2,
			long partIndex3,
			String switchState,
			long controlDevStep,
			long xfrmTapConIndx,
			long xfrmTapSetting,
			String text );
	
	/**
	 * Inserts intermediate geographical points for a line or cable section. Any existing
	 * intermediate points are removed.
	 * @param cktId Unique identifier of circuit to associate component with
	 * @param cmpId ID of component
	 * @param numIntPts Number of intermediate points
	 * @param xPts List of ordered x coordinates starting from the end closest to the
	 * reference source.
	 * @param yPts List of ordered y coordinates.
	 * @return Success (1) or failure (0)
	 */
	public int SetCmpPoints(String cktId, String cmpId, long numIntPts, long[] xPts, long[] yPts);
	
	/**
	 * Connect two components electrically and topologically.
	 * @param ckt1Id ID of circuit containing first component. If set to "unknown" the a
	 * search over all system components is performed.
	 * @param cmp1Id ID of first component to connect
	 * @param ckt2Id ID of circuit containing second component. If set to "unknown" the a
	 * search over all system components is performed.
	 * @param cmp2Id ID of second component to connect.
	 * @return Success (1) or failure (0)
	 */
	public int ConnectCmp(String ck1Id, String cmp1Id, String ckt2Id, String cmp2Id);
	
	/**
	 * Add spot loads to secondary side of transformers based on the connected kVA.
	 * 
	 * @param cktId Circuit where spot loads are to be added. An empty string, "", is
	 * used to specify all circuites in the system (note, use an empty string not Null).
	 * @param cmpId Transformer (UID) where spot load will be added (an empty string
	 * can be used to specify all transformers).
	 * @param ld_powFactorPrc Power factor (in percent) used in defining added loads.
	 * @param kVA_Prc Percentage of a distribution transformer's kVA used in defining added loads.
	 * @param fAddtoCsb Whether to add spot loads to transformers with CSB data attached
	 * (no (0) or yes (1)0.
	 * @param fAddtoKcs Whether to add spot loads to KCS transformers (no (0) or yes (1)).
	 * @param fAddLdOnPhForNullMxBnkXfmPh Whether to add spot loads to extra phases of multi-bank
	 * transformers with open delta connections (no (0) or yes (1)). If yes, an open delta
	 * transformer across AB and BC will also get an added load across AC.
	 * @return Success (1) or failure (0)
	 */
	public int AddSpotLoadsByConkVA(
			String cktId,
			String cmpId,
			int ld_powFactorPrc,
			int kVA_Prc,
			boolean fAddtoCsb,
			boolean fAddtoKcs,
			boolean fAddLdOnPhForNullMxBnkXfmPh);
	
	
	/**
	 * Create a blank circuit model for use in the engine.
	 * 
	 * @param newSystemName Unique name for the new system.
	 * @return Success (1) or failure (0)
	 */
	public int CreateNewSystem(String newSystemName);
	
	/**
	 * Close the specified system.
	 * 
	 * @param systemName Name of the system to close.
	 * @return Success (1) or failure (0)
	 */
	public int closeSystem(String systemName);
	
	/**
	 * Save the system to a file in DEW format.
	 * 
	 * @param filePathName Fully qualified path name to write the model to.
	 * @return Success (1) or failure (0)
	 */
	public int SaveCurrentSystemToFile(String filePathName);
	
	/**
	 * Set the current system to a particular system already in the Engine memory.
	 * 
	 * @param systemName Name of the system to make current.
	 * @return Success (1) or failure (0)
	 */
	public int SetSystemToCurrent(String systemName);
	
	/**
	 * Closes the current system. All associated data and memory are released.
	 * 
	 * @return Success (1) or failure (0)
	 */
	public int CloseCurrentSystem();
	
	
	/**
	 * Specify application arguments to use in analyses if the default application
	 * arguments aren't adequate.
	 * 
	 * @param configurationFilename Fully qualified path name.
	 * @return Success (1) or failure (0)
	 */
	public int LoadApplicationArguments(String configurationFilename);
	
	/**
	 * Whether to use available measurements for the calculations during analyses.
	 * 
	 * @param useMeasurements 1 use measurements, 0 do not.
	 * @return Success (1) or failure (0)
	 */
	public int setUseMeasurements(int useMeasurements);
	
	/**
	 * Used to open or close a sectionalizing device (switch).
	 * 
	 * @param componentUID UID of the switch to operate.
	 * @param close 1 close the switch, 0 open the switch
	 * @return Success (1) or failure (0)
	 */
	public int SwitchCmpByUID(String componentUID, int close);
	
	/**
	 * Run an analysis on the current system. The type of analysis to run is
	 * determined by the Application Identifier (appId).
	 * 
	 * @param appId Application identifier.
	 * @param circuitName Name of the circuit to analyze. "PRESET" if circuits
	 * are already selected. Null to run all circuits.
	 * @param timepoint Hour of year starting from 0.
	 * @return Success (1) or failure (0)
	 */
	public int RunAnalysis(int appId, String circuitName, int timepoint);
	
	/**
	 * Release the memory for the result structures when no longer needed.
	 */
	public void ReleaseResults();
	
	
	
	
	
	
	
}
